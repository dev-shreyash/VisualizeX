[
    {
      "key": "bubbleSort",
      "python": "def bubbleSort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n    return arr",
      "java": "public class BubbleSort {\n    public static void bubbleSort(int[] arr) {\n        int n = arr.length;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n-i-1; j++) {\n                if (arr[j] > arr[j+1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j+1];\n                    arr[j+1] = temp;\n                }\n            }\n        }\n    }\n}",
      "c": "#include <stdio.h>\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n-i-1; j++) {\n            if (arr[j] > arr[j+1]) {\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n}",
      "cpp": "#include <iostream>\nusing namespace std;\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n-i-1; j++) {\n            if (arr[j] > arr[j+1]) {\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n}",
      "csharp": "using System;\nclass Program {\n    static void BubbleSort(int[] arr) {\n        int n = arr.Length;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n-i-1; j++) {\n                if (arr[j] > arr[j+1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j+1];\n                    arr[j+1] = temp;\n                }\n            }\n        }\n    }\n}",
      "javascript": "function bubbleSort(arr) {\n    let n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n-i-1; j++) {\n            if (arr[j] > arr[j+1]) {\n                let temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n}"
    },
    {
      "key": "mergeSortTopDown",
      "python": "def mergeSortTopDown(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n        mergeSortTopDown(left_half)\n        mergeSortTopDown(right_half)\n        i = j = k = 0\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n    return arr",
      "java": "public class mergeSortTopDown {\n    public static void mergeSortTopDown(int[] arr) {\n        if (arr.length > 1) {\n            int mid = arr.length / 2;\n            int[] left = new int[mid];\n            int[] right = new int[arr.length - mid];\n            System.arraycopy(arr, 0, left, 0, mid);\n            System.arraycopy(arr, mid, right, 0, arr.length - mid);\n            mergeSortTopDown(left);\n            mergeSortTopDown(right);\n            merge(arr, left, right);\n        }\n    }\n    public static void merge(int[] arr, int[] left, int[] right) {\n        int i = 0, j = 0, k = 0;\n        while (i < left.length && j < right.length) {\n            if (left[i] <= right[j]) {\n                arr[k++] = left[i++];\n            } else {\n                arr[k++] = right[j++];\n            }\n        }\n        while (i < left.length) arr[k++] = left[i++];\n        while (j < right.length) arr[k++] = right[j++];\n    }\n}",
      "c": "#include <stdio.h>\nvoid mergeSortTopDown(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSortTopDown(arr, l, m);\n        mergeSortTopDown(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\nvoid merge(int arr[], int l, int m, int r) {\n    int n1 = m - l + 1;\n    int n2 = r - m;\n    int L[n1], R[n2];\n    for (int i = 0; i < n1; i++) L[i] = arr[l + i];\n    for (int j = 0; j < n2; j++) R[j] = arr[m + 1 + j];\n    int i = 0, j = 0, k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) arr[k++] = L[i++];\n        else arr[k++] = R[j++];\n    }\n    while (i < n1) arr[k++] = L[i++];\n    while (j < n2) arr[k++] = R[j++];\n}",
      "cpp": "#include <iostream>\nusing namespace std;\nvoid mergeSortTopDown(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSortTopDown(arr, l, m);\n        mergeSortTopDown(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\nvoid merge(int arr[], int l, int m, int r) {\n    int n1 = m - l + 1;\n    int n2 = r - m;\n    int L[n1], R[n2];\n    for (int i = 0; i < n1; i++) L[i] = arr[l + i];\n    for (int j = 0; j < n2; j++) R[j] = arr[m + 1 + j];\n    int i = 0, j = 0, k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) arr[k++] = L[i++];\n        else arr[k++] = R[j++];\n    }\n    while (i < n1) arr[k++] = L[i++];\n    while (j < n2) arr[k++] = R[j++];\n}",
      "csharp": "using System;\nclass Program {\n    static void mergeSortTopDown(int[] arr, int l, int r) {\n        if (l < r) {\n            int m = l + (r - l) / 2;\n            mergeSortTopDown(arr, l, m);\n            mergeSortTopDown(arr, m + 1, r);\n            Merge(arr, l, m, r);\n        }\n    }\n    static void Merge(int[] arr, int l, int m, int r) {\n        int n1 = m - l + 1, n2 = r - m;\n        int[] L = new int[n1], R = new int[n2];\n        Array.Copy(arr, l, L, 0, n1);\n        Array.Copy(arr, m + 1, R, 0, n2);\n        int i = 0, j = 0, k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) arr[k++] = L[i++];\n            else arr[k++] = R[j++];\n        }\n        while (i < n1) arr[k++] = L[i++];\n        while (j < n2) arr[k++] = R[j++];\n    }\n}",
      "javascript": "function mergeSortTopDown(arr) {\n    if (arr.length <= 1) return arr;\n    let mid = Math.floor(arr.length / 2);\n    let left = mergeSortTopDown(arr.slice(0, mid));\n    let right = mergeSortTopDown(arr.slice(mid));\n    return merge(left, right);\n}\nfunction merge(left, right) {\n    let result = [];\n    let i = 0, j = 0;\n    while (i < left.length && j < right.length) {\n        if (left[i] < right[j]) result.push(left[i++]);\n        else result.push(right[j++]);\n    }\n    return result.concat(left.slice(i), right.slice(j));\n}"
    },
    {
      "key": "mergeSortBottomUp",
      "python": "def mergeSortBottomUp(arr):\n    n = len(arr)\n    size = 1\n    while size < n:\n        for start in range(0, n, 2 * size):\n            mid = min(start + size, n)\n            end = min(start + 2 * size, n)\n            merged = []\n            i, j = start, mid\n            while i < mid and j < end:\n                if arr[i] <= arr[j]:\n                    merged.append(arr[i])\n                    i += 1\n                else:\n                    merged.append(arr[j])\n                    j += 1\n            merged.extend(arr[i:mid])\n            merged.extend(arr[j:end])\n            arr[start:end] = merged\n        size *= 2\n    return arr",
      "java": "public class MergeSortBottomUp {\n    public static void mergeSortBottomUp(int[] arr) {\n        int n = arr.length;\n        for (int size = 1; size < n; size *= 2) {\n            for (int start = 0; start < n; start += 2 * size) {\n                int mid = Math.min(start + size, n);\n                int end = Math.min(start + 2 * size, n);\n                int[] merged = new int[end - start];\n                int i = start, j = mid, k = 0;\n                while (i < mid && j < end) {\n                    if (arr[i] <= arr[j]) {\n                        merged[k++] = arr[i++];\n                    } else {\n                        merged[k++] = arr[j++];\n                    }\n                }\n                while (i < mid) {\n                    merged[k++] = arr[i++];\n                }\n                while (j < end) {\n                    merged[k++] = arr[j++];\n                }\n                System.arraycopy(merged, 0, arr, start, merged.length);\n            }\n        }\n    }\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\nvoid merge(int arr[], int start, int mid, int end) {\n    int n1 = mid - start, n2 = end - mid;\n    int left[n1], right[n2];\n    for (int i = 0; i < n1; i++) left[i] = arr[start + i];\n    for (int i = 0; i < n2; i++) right[i] = arr[mid + i];\n    int i = 0, j = 0, k = start;\n    while (i < n1 && j < n2) {\n        if (left[i] <= right[j]) arr[k++] = left[i++];\n        else arr[k++] = right[j++];\n    }\n    while (i < n1) arr[k++] = left[i++];\n    while (j < n2) arr[k++] = right[j++];\n}\nvoid mergeSortBottomUp(int arr[], int n) {\n    for (int size = 1; size < n; size *= 2) {\n        for (int start = 0; start < n; start += 2 * size) {\n            int mid = start + size < n ? start + size : n;\n            int end = start + 2 * size < n ? start + 2 * size : n;\n            merge(arr, start, mid, end);\n        }\n    }\n}",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\nvoid merge(vector<int>& arr, int start, int mid, int end) {\n    vector<int> left(arr.begin() + start, arr.begin() + mid);\n    vector<int> right(arr.begin() + mid, arr.begin() + end);\n    int i = 0, j = 0, k = start;\n    while (i < left.size() && j < right.size()) {\n        if (left[i] <= right[j]) arr[k++] = left[i++];\n        else arr[k++] = right[j++];\n    }\n    while (i < left.size()) arr[k++] = left[i++];\n    while (j < right.size()) arr[k++] = right[j++];\n}\nvoid mergeSortBottomUp(vector<int>& arr) {\n    int n = arr.size();\n    for (int size = 1; size < n; size *= 2) {\n        for (int start = 0; start < n; start += 2 * size) {\n            int mid = min(start + size, n);\n            int end = min(start + 2 * size, n);\n            merge(arr, start, mid, end);\n        }\n    }\n}",
      "csharp": "using System;\nclass Program {\n    static void Merge(int[] arr, int start, int mid, int end) {\n        int[] left = new int[mid - start];\n        int[] right = new int[end - mid];\n        Array.Copy(arr, start, left, 0, left.Length);\n        Array.Copy(arr, mid, right, 0, right.Length);\n        int i = 0, j = 0, k = start;\n        while (i < left.Length && j < right.Length) {\n            if (left[i] <= right[j]) arr[k++] = left[i++];\n            else arr[k++] = right[j++];\n        }\n        while (i < left.Length) arr[k++] = left[i++];\n        while (j < right.Length) arr[k++] = right[j++];\n    }\n    static void MergeSortBottomUp(int[] arr) {\n        int n = arr.Length;\n        for (int size = 1; size < n; size *= 2) {\n            for (int start = 0; start < n; start += 2 * size) {\n                int mid = Math.Min(start + size, n);\n                int end = Math.Min(start + 2 * size, n);\n                Merge(arr, start, mid, end);\n            }\n        }\n    }\n}",
      "javascript": "function mergeSortBottomUp(arr) {\n    let n = arr.length;\n    for (let size = 1; size < n; size *= 2) {\n        for (let start = 0; start < n; start += 2 * size) {\n            let mid = Math.min(start + size, n);\n            let end = Math.min(start + 2 * size, n);\n            let merged = [];\n            let i = start, j = mid;\n            while (i < mid && j < end) {\n                if (arr[i] <= arr[j]) merged.push(arr[i++]);\n                else merged.push(arr[j++]);\n            }\n            merged = merged.concat(arr.slice(i, mid), arr.slice(j, end));\n            arr.splice(start, merged.length, ...merged);\n        }\n    }\n    return arr;\n}"
    },
    {
      "key": "quickSort",
      "python": "def quickSort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quickSort(left) + middle + quickSort(right)",
      "java": "public class QuickSort {\n    public static void quickSort(int[] arr, int low, int high) {\n        if (low < high) {\n            int pi = partition(arr, low, high);\n            quickSort(arr, low, pi - 1);\n            quickSort(arr, pi + 1, high);\n        }\n    }\n    public static int partition(int[] arr, int low, int high) {\n        int pivot = arr[high];\n        int i = (low - 1);\n        for (int j = low; j < high; j++) {\n            if (arr[j] <= pivot) {\n                i++;\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n        int temp = arr[i + 1];\n        arr[i + 1] = arr[high];\n        arr[high] = temp;\n        return i + 1;\n    }\n}",
      "c": "#include <stdio.h>\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n    for (int j = low; j < high; j++) {\n        if (arr[j] <= pivot) {\n            i++;\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n    return (i + 1);\n}\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}",
      "cpp": "#include <iostream>\nusing namespace std;\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = (low - 1);\n    for (int j = low; j < high; j++) {\n        if (arr[j] <= pivot) {\n            i++;\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n    return (i + 1);\n}\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}",
      "csharp": "using System;\nclass Program {\n    static int Partition(int[] arr, int low, int high) {\n        int pivot = arr[high];\n        int i = low - 1;\n        for (int j = low; j < high; j++) {\n            if (arr[j] <= pivot) {\n                i++;\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n        int temp1 = arr[i + 1];\n        arr[i + 1] = arr[high];\n        arr[high] = temp1;\n        return i + 1;\n    }\n    static void QuickSort(int[] arr, int low, int high) {\n        if (low < high) {\n            int pi = Partition(arr, low, high);\n            QuickSort(arr, low, pi - 1);\n            QuickSort(arr, pi + 1, high);\n        }\n    }\n}",
      "javascript": "function quickSort(arr) {\n    if (arr.length <= 1) return arr;\n    let pivot = arr[arr.length - 1];\n    let left = [], right = [];\n    for (let i = 0; i < arr.length - 1; i++) {\n        if (arr[i] < pivot) left.push(arr[i]);\n        else right.push(arr[i]);\n    }\n    return [...quickSort(left), pivot, ...quickSort(right)];\n}"
    },
    {
      "key": "selectionSort",
      "python": "def selectionSort(arr):\n    for i in range(len(arr)):\n        min_idx = i\n        for j in range(i+1, len(arr)):\n            if arr[j] < arr[min_idx]:\n                min_idx = j\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n    return arr",
      "java": "public class SelectionSort {\n    public static void selectionSort(int[] arr) {\n        for (int i = 0; i < arr.length - 1; i++) {\n            int min_idx = i;\n            for (int j = i + 1; j < arr.length; j++) {\n                if (arr[j] < arr[min_idx]) {\n                    min_idx = j;\n                }\n            }\n            int temp = arr[min_idx];\n            arr[min_idx] = arr[i];\n            arr[i] = temp;\n        }\n    }\n}",
      "c": "#include <stdio.h>\nvoid selectionSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        int min_idx = i;\n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_idx]) {\n                min_idx = j;\n            }\n        }\n        int temp = arr[min_idx];\n        arr[min_idx] = arr[i];\n        arr[i] = temp;\n    }\n}",
      "cpp": "#include <iostream>\nusing namespace std;\nvoid selectionSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        int min_idx = i;\n        for (int j = i + 1; j < n; j++) {\n            if (arr[j] < arr[min_idx]) {\n                min_idx = j;\n            }\n        }\n        int temp = arr[min_idx];\n        arr[min_idx] = arr[i];\n        arr[i] = temp;\n    }\n}",
      "csharp": "using System;\nclass Program {\n    static void SelectionSort(int[] arr) {\n        for (int i = 0; i < arr.Length - 1; i++) {\n            int min_idx = i;\n            for (int j = i + 1; j < arr.Length; j++) {\n                if (arr[j] < arr[min_idx]) {\n                    min_idx = j;\n                }\n            }\n            int temp = arr[min_idx];\n            arr[min_idx] = arr[i];\n            arr[i] = temp;\n        }\n    }\n}",
      "javascript": "function selectionSort(arr) {\n    for (let i = 0; i < arr.length - 1; i++) {\n        let min_idx = i;\n        for (let j = i + 1; j < arr.length; j++) {\n            if (arr[j] < arr[min_idx]) {\n                min_idx = j;\n            }\n        }\n        [arr[i], arr[min_idx]] = [arr[min_idx], arr[i]];\n    }\n    return arr;\n}"
    },
    {
      "key": "insertionSort",
      "python": "def insertionSort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n    return arr",
      "java": "public class InsertionSort {\n    public static void insertionSort(int[] arr) {\n        for (int i = 1; i < arr.length; i++) {\n            int key = arr[i];\n            int j = i - 1;\n            while (j >= 0 && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j--;\n            }\n            arr[j + 1] = key;\n        }\n    }\n}",
      "c": "#include <stdio.h>\nvoid insertionSort(int arr[], int n) {\n    for (int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}",
      "cpp": "#include <iostream>\nusing namespace std;\nvoid insertionSort(int arr[], int n) {\n    for (int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}",
      "csharp": "using System;\nclass Program {\n    static void InsertionSort(int[] arr) {\n        for (int i = 1; i < arr.Length; i++) {\n            int key = arr[i];\n            int j = i - 1;\n            while (j >= 0 && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j--;\n            }\n            arr[j + 1] = key;\n        }\n    }\n}",
      "javascript": "function insertionSort(arr) {\n    for (let i = 1; i < arr.length; i++) {\n        let key = arr[i];\n        let j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n    return arr;\n}"
    },
    {
      "key": "gnomeSort",
      "python": "def gnomeSort(arr):\n    index = 0\n    while index < len(arr):\n        if index == 0 or arr[index] >= arr[index - 1]:\n            index += 1\n        else:\n            arr[index], arr[index - 1] = arr[index - 1], arr[index]\n            index -= 1\n    return arr",
      "java": "public class GnomeSort {\n    public static void gnomeSort(int[] arr) {\n        int index = 0;\n        while (index < arr.length) {\n            if (index == 0 || arr[index] >= arr[index - 1]) {\n                index++;\n            } else {\n                int temp = arr[index];\n                arr[index] = arr[index - 1];\n                arr[index - 1] = temp;\n                index--;\n            }\n        }\n    }\n}",
      "c": "#include <stdio.h>\nvoid gnomeSort(int arr[], int n) {\n    int index = 0;\n    while (index < n) {\n        if (index == 0 || arr[index] >= arr[index - 1]) {\n            index++;\n        } else {\n            int temp = arr[index];\n            arr[index] = arr[index - 1];\n            arr[index - 1] = temp;\n            index--;\n        }\n    }\n}",
      "cpp": "#include <iostream>\nusing namespace std;\nvoid gnomeSort(int arr[], int n) {\n    int index = 0;\n    while (index < n) {\n        if (index == 0 || arr[index] >= arr[index - 1]) {\n            index++;\n        } else {\n            int temp = arr[index];\n            arr[index] = arr[index - 1];\n            arr[index - 1] = temp;\n            index--;\n        }\n    }\n}",
      "csharp": "using System;\nclass Program {\n    static void GnomeSort(int[] arr) {\n        int index = 0;\n        while (index < arr.Length) {\n            if (index == 0 || arr[index] >= arr[index - 1]) {\n                index++;\n            } else {\n                int temp = arr[index];\n                arr[index] = arr[index - 1];\n                arr[index - 1] = temp;\n                index--;\n            }\n        }\n    }\n}",
      "javascript": "function gnomeSort(arr) {\n    let index = 0;\n    while (index < arr.length) {\n        if (index === 0 || arr[index] >= arr[index - 1]) {\n            index++;\n        } else {\n            [arr[index], arr[index - 1]] = [arr[index - 1], arr[index]];\n            index--;\n        }\n    }\n    return arr;\n}"
    },
    {
      "key": "combSort",
      "python": "def combSort(arr):\n    gap = len(arr)\n    shrink = 1.3\n    sorted = False\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        i = 0\n        while i + gap < len(arr):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n            i += 1\n    return arr",
      "java": "public class CombSort {\n    public static void combSort(int[] arr) {\n        int gap = arr.length;\n        double shrink = 1.3;\n        boolean sorted = false;\n        while (!sorted) {\n            gap = (int) (gap / shrink);\n            if (gap <= 1) {\n                gap = 1;\n                sorted = true;\n            }\n            int i = 0;\n            while (i + gap < arr.length) {\n                if (arr[i] > arr[i + gap]) {\n                    int temp = arr[i];\n                    arr[i] = arr[i + gap];\n                    arr[i + gap] = temp;\n                    sorted = false;\n                }\n                i++;\n            }\n        }\n    }\n}",
      "c": "#include <stdio.h>\nvoid combSort(int arr[], int n) {\n    int gap = n;\n    float shrink = 1.3;\n    int sorted = 0;\n    while (!sorted) {\n        gap = (int) (gap / shrink);\n        if (gap <= 1) {\n            gap = 1;\n            sorted = 1;\n        }\n        int i = 0;\n        while (i + gap < n) {\n            if (arr[i] > arr[i + gap]) {\n                int temp = arr[i];\n                arr[i] = arr[i + gap];\n                arr[i + gap] = temp;\n                sorted = 0;\n            }\n            i++;\n        }\n    }\n}",
      "cpp": "#include <iostream>\nusing namespace std;\nvoid combSort(int arr[], int n) {\n    int gap = n;\n    float shrink = 1.3;\n    bool sorted = false;\n    while (!sorted) {\n        gap = (int)(gap / shrink);\n        if (gap <= 1) {\n            gap = 1;\n            sorted = true;\n        }\n        int i = 0;\n        while (i + gap < n) {\n            if (arr[i] > arr[i + gap]) {\n                swap(arr[i], arr[i + gap]);\n                sorted = false;\n            }\n            i++;\n        }\n    }\n}",
      "csharp": "using System;\nclass Program {\n    static void CombSort(int[] arr) {\n        int gap = arr.Length;\n        double shrink = 1.3;\n        bool sorted = false;\n        while (!sorted) {\n            gap = (int)(gap / shrink);\n            if (gap <= 1) {\n                gap = 1;\n                sorted = true;\n            }\n            int i = 0;\n            while (i + gap < arr.Length) {\n                if (arr[i] > arr[i + gap]) {\n                    int temp = arr[i];\n                    arr[i] = arr[i + gap];\n                    arr[i + gap] = temp;\n                    sorted = false;\n                }\n                i++;\n            }\n        }\n    }\n}",
      "javascript": "function combSort(arr) {\n    let gap = arr.length;\n    const shrink = 1.3;\n    let sorted = false;\n    while (!sorted) {\n        gap = Math.floor(gap / shrink);\n        if (gap <= 1) {\n            gap = 1;\n            sorted = true;\n        }\n        let i = 0;\n        while (i + gap < arr.length) {\n            if (arr[i] > arr[i + gap]) {\n                [arr[i], arr[i + gap]] = [arr[i + gap], arr[i]];\n                sorted = false;\n            }\n            i++;\n        }\n    }\n    return arr;\n}"
    },
    {
      "key": "oddEvenSort",
      "python": "def odd_even_sort(arr):\n    n = len(arr)\n    sorted = False\n    while not sorted:\n        sorted = True\n        # Odd phase\n        for i in range(1, n - 1, 2):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                sorted = False\n        # Even phase\n        for i in range(0, n - 1, 2):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                sorted = False\n    return arr",
      "java": "public class OddEvenSort {\n    public static void oddEvenSort(int[] arr) {\n        int n = arr.length;\n        boolean sorted = false;\n        while (!sorted) {\n            sorted = true;\n            // Odd phase\n            for (int i = 1; i < n - 1; i += 2) {\n                if (arr[i] > arr[i + 1]) {\n                    int temp = arr[i];\n                    arr[i] = arr[i + 1];\n                    arr[i + 1] = temp;\n                    sorted = false;\n                }\n            }\n            // Even phase\n            for (int i = 0; i < n - 1; i += 2) {\n                if (arr[i] > arr[i + 1]) {\n                    int temp = arr[i];\n                    arr[i] = arr[i + 1];\n                    arr[i + 1] = temp;\n                    sorted = false;\n                }\n            }\n        }\n    }\n}",
      "c": "#include <stdio.h>\nvoid oddEvenSort(int arr[], int n) {\n    int sorted = 0;\n    while (!sorted) {\n        sorted = 1;\n        // Odd phase\n        for (int i = 1; i < n - 1; i += 2) {\n            if (arr[i] > arr[i + 1]) {\n                int temp = arr[i];\n                arr[i] = arr[i + 1];\n                arr[i + 1] = temp;\n                sorted = 0;\n            }\n        }\n        // Even phase\n        for (int i = 0; i < n - 1; i += 2) {\n            if (arr[i] > arr[i + 1]) {\n                int temp = arr[i];\n                arr[i] = arr[i + 1];\n                arr[i + 1] = temp;\n                sorted = 0;\n            }\n        }\n    }\n}",
      "cpp": "#include <iostream>\nusing namespace std;\nvoid oddEvenSort(int arr[], int n) {\n    bool sorted = false;\n    while (!sorted) {\n        sorted = true;\n        // Odd phase\n        for (int i = 1; i < n - 1; i += 2) {\n            if (arr[i] > arr[i + 1]) {\n                swap(arr[i], arr[i + 1]);\n                sorted = false;\n            }\n        }\n        // Even phase\n        for (int i = 0; i < n - 1; i += 2) {\n            if (arr[i] > arr[i + 1]) {\n                swap(arr[i], arr[i + 1]);\n                sorted = false;\n            }\n        }\n    }\n}",
      "csharp": "using System;\nclass Program {\n    static void OddEvenSort(int[] arr) {\n        int n = arr.Length;\n        bool sorted = false;\n        while (!sorted) {\n            sorted = true;\n            // Odd phase\n            for (int i = 1; i < n - 1; i += 2) {\n                if (arr[i] > arr[i + 1]) {\n                    int temp = arr[i];\n                    arr[i] = arr[i + 1];\n                    arr[i + 1] = temp;\n                    sorted = false;\n                }\n            }\n            // Even phase\n            for (int i = 0; i < n - 1; i += 2) {\n                if (arr[i] > arr[i + 1]) {\n                    int temp = arr[i];\n                    arr[i] = arr[i + 1];\n                    arr[i + 1] = temp;\n                    sorted = false;\n                }\n            }\n        }\n    }\n}",
      "javascript": "function oddEvenSort(arr) {\n    let n = arr.length;\n    let sorted = false;\n    while (!sorted) {\n        sorted = true;\n        // Odd phase\n        for (let i = 1; i < n - 1; i += 2) {\n            if (arr[i] > arr[i + 1]) {\n                [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];\n                sorted = false;\n            }\n        }\n        // Even phase\n        for (let i = 0; i < n - 1; i += 2) {\n            if (arr[i] > arr[i + 1]) {\n                [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];\n                sorted = false;\n            }\n        }\n    }\n    return arr;\n}"
    },
    {
      "key": "shellSort",
      "python": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr",
      "java": "public class ShellSort {\n    public static void shellSort(int[] arr) {\n        int n = arr.length;\n        for (int gap = n / 2; gap > 0; gap /= 2) {\n            for (int i = gap; i < n; i++) {\n                int temp = arr[i];\n                int j = i;\n                while (j >= gap && arr[j - gap] > temp) {\n                    arr[j] = arr[j - gap];\n                    j -= gap;\n                }\n                arr[j] = temp;\n            }\n        }\n    }\n}",
      "c": "#include <stdio.h>\nvoid shellSort(int arr[], int n) {\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        for (int i = gap; i < n; i++) {\n            int temp = arr[i];\n            int j = i;\n            while (j >= gap && arr[j - gap] > temp) {\n                arr[j] = arr[j - gap];\n                j -= gap;\n            }\n            arr[j] = temp;\n        }\n    }\n}",
      "cpp": "#include <iostream>\nusing namespace std;\nvoid shellSort(int arr[], int n) {\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        for (int i = gap; i < n; i++) {\n            int temp = arr[i];\n            int j = i;\n            while (j >= gap && arr[j - gap] > temp) {\n                arr[j] = arr[j - gap];\n                j -= gap;\n            }\n            arr[j] = temp;\n        }\n    }\n}",
      "csharp": "using System;\nclass Program {\n    static void ShellSort(int[] arr) {\n        int n = arr.Length;\n        for (int gap = n / 2; gap > 0; gap /= 2) {\n            for (int i = gap; i < n; i++) {\n                int temp = arr[i];\n                int j = i;\n                while (j >= gap && arr[j - gap] > temp) {\n                    arr[j] = arr[j - gap];\n                    j -= gap;\n                }\n                arr[j] = temp;\n            }\n        }\n    }\n}",
      "javascript": "function shellSort(arr) {\n    let n = arr.length;\n    for (let gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2)) {\n        for (let i = gap; i < n; i++) {\n            let temp = arr[i];\n            let j = i;\n            while (j >= gap && arr[j - gap] > temp) {\n                arr[j] = arr[j - gap];\n                j -= gap;\n            }\n            arr[j] = temp;\n        }\n    }\n    return arr;\n}"
    },
    {
      "key": "pancakeSort",
      "python": "def pancakeSort(arr):\n    def flip(arr, i):\n        arr[:i + 1] = arr[:i + 1][::-1]\n\n    n = len(arr)\n    for i in range(n, 1, -1):\n        max_idx = arr.index(max(arr[:i]))\n        if max_idx != i - 1:\n            if max_idx != 0:\n                flip(arr, max_idx)\n            flip(arr, i - 1)\n    return arr",
      "java": "public class PancakeSort {\n    public static void flip(int[] arr, int i) {\n        int start = 0;\n        while (start < i) {\n            int temp = arr[start];\n            arr[start] = arr[i];\n            arr[i] = temp;\n            start++;\n            i--;\n        }\n    }\n\n    public static int[] pancakeSort(int[] arr) {\n        int n = arr.length;\n        for (int i = n; i > 1; i--) {\n            int maxIdx = 0;\n            for (int j = 1; j < i; j++) {\n                if (arr[j] > arr[maxIdx]) {\n                    maxIdx = j;\n                }\n            }\n            if (maxIdx != i - 1) {\n                if (maxIdx != 0) {\n                    flip(arr, maxIdx);\n                }\n                flip(arr, i - 1);\n            }\n        }\n        return arr;\n    }\n}",
      "c": "#include <stdio.h>\nvoid flip(int arr[], int i) {\n    int start = 0;\n    while (start < i) {\n        int temp = arr[start];\n        arr[start] = arr[i];\n        arr[i] = temp;\n        start++;\n        i--;\n    }\n}\n\nvoid pancakeSort(int arr[], int n) {\n    for (int i = n; i > 1; i--) {\n        int maxIdx = 0;\n        for (int j = 1; j < i; j++) {\n            if (arr[j] > arr[maxIdx]) {\n                maxIdx = j;\n            }\n        }\n        if (maxIdx != i - 1) {\n            if (maxIdx != 0) {\n                flip(arr, maxIdx);\n            }\n            flip(arr, i - 1);\n        }\n    }\n}",
      "cpp": "#include <iostream>\nusing namespace std;\n\nvoid flip(int arr[], int i) {\n    int start = 0;\n    while (start < i) {\n        int temp = arr[start];\n        arr[start] = arr[i];\n        arr[i] = temp;\n        start++;\n        i--;\n    }\n}\n\nvoid pancakeSort(int arr[], int n) {\n    for (int i = n; i > 1; i--) {\n        int maxIdx = 0;\n        for (int j = 1; j < i; j++) {\n            if (arr[j] > arr[maxIdx]) {\n                maxIdx = j;\n            }\n        }\n        if (maxIdx != i - 1) {\n            if (maxIdx != 0) {\n                flip(arr, maxIdx);\n            }\n            flip(arr, i - 1);\n        }\n    }\n}",
      "csharp": "using System;\nclass PancakeSort {\n    public static void Flip(int[] arr, int i) {\n        int start = 0;\n        while (start < i) {\n            int temp = arr[start];\n            arr[start] = arr[i];\n            arr[i] = temp;\n            start++;\n            i--;\n        }\n    }\n\n    public static void PancakeSortMethod(int[] arr) {\n        int n = arr.Length;\n        for (int i = n; i > 1; i--) {\n            int maxIdx = 0;\n            for (int j = 1; j < i; j++) {\n                if (arr[j] > arr[maxIdx]) {\n                    maxIdx = j;\n                }\n            }\n            if (maxIdx != i - 1) {\n                if (maxIdx != 0) {\n                    Flip(arr, maxIdx);\n                }\n                Flip(arr, i - 1);\n            }\n        }\n    }\n}",
      "javascript": "function pancakeSort(arr) {\n    function flip(arr, i) {\n        arr.splice(0, i + 1, ...arr.slice(0, i + 1).reverse());\n    }\n\n    let n = arr.length;\n    for (let i = n; i > 1; i--) {\n        let maxIdx = 0;\n        for (let j = 1; j < i; j++) {\n            if (arr[j] > arr[maxIdx]) {\n                maxIdx = j;\n            }\n        }\n        if (maxIdx !== i - 1) {\n            if (maxIdx !== 0) {\n                flip(arr, maxIdx);\n            }\n            flip(arr, i - 1);\n        }\n    }\n    return arr;\n}"
    },
    {
      "key": "bogoSort",
      "python": "import random\n\ndef bogoSort(arr):\n    while not sorted(arr):\n        random.shuffle(arr)\n    return arr",
      "java": "import java.util.Random;\n\npublic class BogoSort {\n    public static int[] bogoSort(int[] arr) {\n        Random rand = new Random();\n        while (!isSorted(arr)) {\n            for (int i = 0; i < arr.length; i++) {\n                int j = rand.nextInt(arr.length);\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n        return arr;\n    }\n\n    private static boolean isSorted(int[] arr) {\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] < arr[i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nvoid bogoSort(int arr[], int n) {\n    srand(time(0));\n    while (!isSorted(arr, n)) {\n        for (int i = 0; i < n; i++) {\n            int j = rand() % n;\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n}\n\nint isSorted(int arr[], int n) {\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[i - 1]) {\n            return 0;\n        }\n    }\n    return 1;\n}",
      "cpp": "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nvoid bogoSort(int arr[], int n) {\n    srand(time(0));\n    while (!isSorted(arr, n)) {\n        for (int i = 0; i < n; i++) {\n            int j = rand() % n;\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n}\n\nbool isSorted(int arr[], int n) {\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}",
      "csharp": "using System;\nusing System.Linq;\n\nclass BogoSort {\n    public static int[] BogoSortMethod(int[] arr) {\n        Random rand = new Random();\n        while (!IsSorted(arr)) {\n            for (int i = 0; i < arr.Length; i++) {\n                int j = rand.Next(arr.Length);\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n        return arr;\n    }\n\n    private static bool IsSorted(int[] arr) {\n        for (int i = 1; i < arr.Length; i++) {\n            if (arr[i] < arr[i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
      "javascript": "function bogoSort(arr) {\n    function isSorted(arr) {\n        for (let i = 1; i < arr.length; i++) {\n            if (arr[i] < arr[i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    while (!isSorted(arr)) {\n        for (let i = 0; i < arr.length; i++) {\n            let j = Math.floor(Math.random() * arr.length);\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    return arr;\n}"
    },
    {
      "key": "cycleSort",
      "python": "def cycleSort(arr):\n    writes = 0\n    for cycleStart in range(0, len(arr) - 1):\n        item = arr[cycleStart]\n        pos = cycleStart\n        for i in range(cycleStart + 1, len(arr)):\n            if arr[i] < item:\n                pos += 1\n        if pos == cycleStart:\n            continue\n        while item == arr[pos]:\n            pos += 1\n        arr[pos], item = item, arr[pos]\n        writes += 1\n        while pos != cycleStart:\n            pos = cycleStart\n            for i in range(cycleStart + 1, len(arr)):\n                if arr[i] < item:\n                    pos += 1\n            while item == arr[pos]:\n                pos += 1\n            arr[pos], item = item, arr[pos]\n            writes += 1\n    return arr",
      "java": "public class CycleSort {\n    public static int[] cycleSort(int[] arr) {\n        int writes = 0;\n        for (int cycleStart = 0; cycleStart < arr.length - 1; cycleStart++) {\n            int item = arr[cycleStart];\n            int pos = cycleStart;\n            for (int i = cycleStart + 1; i < arr.length; i++) {\n                if (arr[i] < item) {\n                    pos++;\n                }\n            }\n            if (pos == cycleStart) {\n                continue;\n            }\n            while (item == arr[pos]) {\n                pos++;\n            }\n            int temp = arr[pos];\n            arr[pos] = item;\n            item = temp;\n            writes++;\n            while (pos != cycleStart) {\n                pos = cycleStart;\n                for (int i = cycleStart + 1; i < arr.length; i++) {\n                    if (arr[i] < item) {\n                        pos++;\n                    }\n                }\n                while (item == arr[pos]) {\n                    pos++;\n                }\n                temp = arr[pos];\n                arr[pos] = item;\n                item = temp;\n                writes++;\n            }\n        }\n        return arr;\n    }\n}",
      "c": "#include <stdio.h>\nvoid cycleSort(int arr[], int n) {\n    int writes = 0;\n    for (int cycleStart = 0; cycleStart < n - 1; cycleStart++) {\n        int item = arr[cycleStart];\n        int pos = cycleStart;\n        for (int i = cycleStart + 1; i < n; i++) {\n            if (arr[i] < item) {\n                pos++;\n            }\n        }\n        if (pos == cycleStart) {\n            continue;\n        }\n        while (item == arr[pos]) {\n            pos++;\n        }\n        arr[pos] = item;\n        writes++;\n        while (pos != cycleStart) {\n            pos = cycleStart;\n            for (int i = cycleStart + 1; i < n; i++) {\n                if (arr[i] < item) {\n                    pos++;\n                }\n            }\n            while (item == arr[pos]) {\n                pos++;\n            }\n            arr[pos] = item;\n            writes++;\n        }\n    }\n}",
      "cpp": "#include <iostream>\nusing namespace std;\n\nvoid cycleSort(int arr[], int n) {\n    int writes = 0;\n    for (int cycleStart = 0; cycleStart < n - 1; cycleStart++) {\n        int item = arr[cycleStart];\n        int pos = cycleStart;\n        for (int i = cycleStart + 1; i < n; i++) {\n            if (arr[i] < item) {\n                pos++;\n            }\n        }\n        if (pos == cycleStart) {\n            continue;\n        }\n        while (item == arr[pos]) {\n            pos++;\n        }\n        arr[pos] = item;\n        writes++;\n        while (pos != cycleStart) {\n            pos = cycleStart;\n            for (int i = cycleStart + 1; i < n; i++) {\n                if (arr[i] < item) {\n                    pos++;\n                }\n            }\n            while (item == arr[pos]) {\n                pos++;\n            }\n            arr[pos] = item;\n            writes++;\n        }\n    }\n}",
      "csharp": "using System;\n\nclass CycleSort {\n    public static void CycleSortMethod(int[] arr) {\n        int writes = 0;\n        for (int cycleStart = 0; cycleStart < arr.Length - 1; cycleStart++) {\n            int item = arr[cycleStart];\n            int pos = cycleStart;\n            for (int i = cycleStart + 1; i < arr.Length; i++) {\n                if (arr[i] < item) {\n                    pos++;\n                }\n            }\n            if (pos == cycleStart) {\n                continue;\n            }\n            while (item == arr[pos]) {\n                pos++;\n            }\n            arr[pos] = item;\n            writes++;\n            while (pos != cycleStart) {\n                pos = cycleStart;\n                for (int i = cycleStart + 1; i < arr.Length; i++) {\n                    if (arr[i] < item) {\n                        pos++;\n                    }\n                }\n                while (item == arr[pos]) {\n                    pos++;\n                }\n                arr[pos] = item;\n                writes++;\n            }\n        }\n    }\n}",
      "javascript": "function cycleSort(arr) {\n    let writes = 0;\n    for (let cycleStart = 0; cycleStart < arr.length - 1; cycleStart++) {\n        let item = arr[cycleStart];\n        let pos = cycleStart;\n        for (let i = cycleStart + 1; i < arr.length; i++) {\n            if (arr[i] < item) {\n                pos++;\n            }\n        }\n        if (pos === cycleStart) {\n            continue;\n        }\n        while (item === arr[pos]) {\n            pos++;\n        }\n        [arr[pos], item] = [item, arr[pos]];\n        writes++;\n        while (pos !== cycleStart) {\n            pos = cycleStart;\n            for (let i = cycleStart + 1; i < arr.length; i++) {\n                if (arr[i] < item) {\n                    pos++;\n                }\n            }\n            while (item === arr[pos]) {\n                pos++;\n            }\n            [arr[pos], item] = [item, arr[pos]];\n            writes++;\n        }\n    }\n    return arr;\n}"
    },
    {
      "key": "timSort",
      "python": "def timSort(arr):\n    minRun = 32\n    def insertionSort(arr, left, right):\n        for i in range(left + 1, right + 1):\n            key = arr[i]\n            j = i - 1\n            while j >= left and arr[j] > key:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key\n\n    def merge(arr, left, mid, right):\n        len1, len2 = mid - left + 1, right - mid\n        leftArr = arr[left:mid + 1]\n        rightArr = arr[mid + 1:right + 1]\n        i, j, k = 0, 0, left\n        while i < len1 and j < len2:\n            if leftArr[i] <= rightArr[j]:\n                arr[k] = leftArr[i]\n                i += 1\n            else:\n                arr[k] = rightArr[j]\n                j += 1\n            k += 1\n        while i < len1:\n            arr[k] = leftArr[i]\n            i += 1\n            k += 1\n        while j < len2:\n            arr[k] = rightArr[j]\n            j += 1\n            k += 1\n\n    n = len(arr)\n    for i in range(0, n, minRun):\n        insertionSort(arr, i, min((i + minRun - 1), n - 1))\n    size = minRun\n    while size < n:\n        for start in range(0, n, 2 * size):\n            mid = min(n - 1, start + size - 1)\n            end = min((start + 2 * size - 1), (n - 1))\n            if mid < end:\n                merge(arr, start, mid, end)\n        size *= 2\n    return arr",
      "java": "import java.util.Arrays;\n\npublic class TimSort {\n    private static void insertionSort(int[] arr, int left, int right) {\n        for (int i = left + 1; i <= right; i++) {\n            int key = arr[i];\n            int j = i - 1;\n            while (j >= left && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j--;\n            }\n            arr[j + 1] = key;\n        }\n    }\n\n    private static void merge(int[] arr, int left, int mid, int right) {\n        int len1 = mid - left + 1;\n        int len2 = right - mid;\n        int[] leftArr = Arrays.copyOfRange(arr, left, mid + 1);\n        int[] rightArr = Arrays.copyOfRange(arr, mid + 1, right + 1);\n        int i = 0, j = 0, k = left;\n        while (i < len1 && j < len2) {\n            if (leftArr[i] <= rightArr[j]) {\n                arr[k] = leftArr[i];\n                i++;\n            } else {\n                arr[k] = rightArr[j];\n                j++;\n            }\n            k++;\n        }\n        while (i < len1) {\n            arr[k] = leftArr[i];\n            i++;\n            k++;\n        }\n        while (j < len2) {\n            arr[k] = rightArr[j];\n            j++;\n            k++;\n        }\n    }\n\n    public static int[] timSort(int[] arr) {\n        int minRun = 32;\n        int n = arr.length;\n        for (int i = 0; i < n; i += minRun) {\n            insertionSort(arr, i, Math.min(i + minRun - 1, n - 1));\n        }\n        for (int size = minRun; size < n; size *= 2) {\n            for (int start = 0; start < n; start += 2 * size) {\n                int mid = Math.min(n - 1, start + size - 1);\n                int end = Math.min(start + 2 * size - 1, n - 1);\n                if (mid < end) {\n                    merge(arr, start, mid, end);\n                }\n            }\n        }\n        return arr;\n    }\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n\nvoid insertionSort(int arr[], int left, int right) {\n    for (int i = left + 1; i <= right; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= left && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nvoid merge(int arr[], int left, int mid, int right) {\n    int len1 = mid - left + 1;\n    int len2 = right - mid;\n    int leftArr[len1], rightArr[len2];\n    memcpy(leftArr, arr + left, len1 * sizeof(int));\n    memcpy(rightArr, arr + mid + 1, len2 * sizeof(int));\n    int i = 0, j = 0, k = left;\n    while (i < len1 && j < len2) {\n        if (leftArr[i] <= rightArr[j]) {\n            arr[k] = leftArr[i];\n            i++;\n        } else {\n            arr[k] = rightArr[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < len1) {\n        arr[k] = leftArr[i];\n        i++;\n        k++;\n    }\n    while (j < len2) {\n        arr[k] = rightArr[j];\n        j++;\n        k++;\n    }\n}\n\nvoid timSort(int arr[], int n) {\n    int minRun = 32;\n    for (int i = 0; i < n; i += minRun) {\n        insertionSort(arr, i, (i + minRun - 1) < (n - 1) ? (i + minRun - 1) : (n - 1));\n    }\n    for (int size = minRun; size < n; size *= 2) {\n        for (int start = 0; start < n; start += 2 * size) {\n            int mid = (start + size - 1) < (n - 1) ? (start + size - 1) : (n - 1);\n            int end = (start + 2 * size - 1) < (n - 1) ? (start + 2 * size - 1) : (n - 1);\n            if (mid < end) {\n                merge(arr, start, mid, end);\n            }\n        }\n    }\n}",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid insertionSort(vector<int>& arr, int left, int right) {\n    for (int i = left + 1; i <= right; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= left && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nvoid merge(vector<int>& arr, int left, int mid, int right) {\n    int len1 = mid - left + 1;\n    int len2 = right - mid;\n    vector<int> leftArr(arr.begin() + left, arr.begin() + mid + 1);\n    vector<int> rightArr(arr.begin() + mid + 1, arr.begin() + right + 1);\n    int i = 0, j = 0, k = left;\n    while (i < len1 && j < len2) {\n        if (leftArr[i] <= rightArr[j]) {\n            arr[k] = leftArr[i];\n            i++;\n        } else {\n            arr[k] = rightArr[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < len1) {\n        arr[k] = leftArr[i];\n        i++;\n        k++;\n    }\n    while (j < len2) {\n        arr[k] = rightArr[j];\n        j++;\n        k++;\n    }\n}\n\nvector<int> timSort(vector<int>& arr) {\n    int n = arr.size();\n    int minRun = 32;\n    for (int i = 0; i < n; i += minRun) {\n        insertionSort(arr, i, min(i + minRun - 1, n - 1));\n    }\n    for (int size = minRun; size < n; size *= 2) {\n        for (int start = 0; start < n; start += 2 * size) {\n            int mid = min(n - 1, start + size - 1);\n            int end = min(start + 2 * size - 1, n - 1);\n            if (mid < end) {\n                merge(arr, start, mid, end);\n            }\n        }\n    }\n    return arr;\n}",
      "csharp": "using System;\n\nclass TimSort {\n    static void InsertionSort(int[] arr, int left, int right) {\n        for (int i = left + 1; i <= right; i++) {\n            int key = arr[i];\n            int j = i - 1;\n            while (j >= left && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j--;\n            }\n            arr[j + 1] = key;\n        }\n    }\n\n    static void Merge(int[] arr, int left, int mid, int right) {\n        int len1 = mid - left + 1;\n        int len2 = right - mid;\n        int[] leftArr = new int[len1];\n        int[] rightArr = new int[len2];\n        Array.Copy(arr, left, leftArr, 0, len1);\n        Array.Copy(arr, mid + 1, rightArr, 0, len2);\n        int i = 0, j = 0, k = left;\n        while (i < len1 && j < len2) {\n            if (leftArr[i] <= rightArr[j]) {\n                arr[k] = leftArr[i];\n                i++;\n            } else {\n                arr[k] = rightArr[j];\n                j++;\n            }\n            k++;\n        }\n        while (i < len1) {\n            arr[k] = leftArr[i];\n            i++;\n            k++;\n        }\n        while (j < len2) {\n            arr[k] = rightArr[j];\n            j++;\n            k++;\n        }\n    }\n\n    public static int[] TimSortMethod(int[] arr) {\n        int n = arr.Length;\n        int minRun = 32;\n        for (int i = 0; i < n; i += minRun) {\n            InsertionSort(arr, i, Math.Min(i + minRun - 1, n - 1));\n        }\n        for (int size = minRun; size < n; size *= 2) {\n            for (int start = 0; start < n; start += 2 * size) {\n                int mid = Math.Min(n - 1, start + size - 1);\n                int end = Math.Min(start + 2 * size - 1, n - 1);\n                if (mid < end) {\n                    Merge(arr, start, mid, end);\n                }\n            }\n        }\n        return arr;\n    }\n}",
      "javascript": "function insertionSort(arr, left, right) {\n    for (let i = left + 1; i <= right; i++) {\n        let key = arr[i];\n        let j = i - 1;\n        while (j >= left && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nfunction merge(arr, left, mid, right) {\n    let len1 = mid - left + 1;\n    let len2 = right - mid;\n    let leftArr = arr.slice(left, mid + 1);\n    let rightArr = arr.slice(mid + 1, right + 1);\n    let i = 0, j = 0, k = left;\n    while (i < len1 && j < len2) {\n        if (leftArr[i] <= rightArr[j]) {\n            arr[k] = leftArr[i];\n            i++;\n        } else {\n            arr[k] = rightArr[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < len1) {\n        arr[k] = leftArr[i];\n        i++;\n        k++;\n    }\n    while (j < len2) {\n        arr[k] = rightArr[j];\n        j++;\n        k++;\n    }\n}\n\nfunction timSort(arr) {\n    const minRun = 32;\n    const n = arr.length;\n    for (let i = 0; i < n; i += minRun) {\n        insertionSort(arr, i, Math.min(i + minRun - 1, n - 1));\n    }\n    for (let size = minRun; size < n; size *= 2) {\n        for (let start = 0; start < n; start += 2 * size) {\n            const mid = Math.min(n - 1, start + size - 1);\n            const end = Math.min(start + 2 * size - 1, n - 1);\n            if (mid < end) {\n                merge(arr, start, mid, end);\n            }\n        }\n    }\n    return arr;\n}"
    },
    {
      "key": "heapSort",
      "python": "def heapify(arr, n, i):\n    largest = i\n    l = 2 * i + 1\n    r = 2 * i + 2\n    if l < n and arr[l] > arr[largest]:\n        largest = l\n    if r < n and arr[r] > arr[largest]:\n        largest = r\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n\ndef heapSort(arr):\n    n = len(arr)\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)\n    return arr",
      "java": "public class HeapSort {\n    public static void heapify(int[] arr, int n, int i) {\n        int largest = i;\n        int l = 2 * i + 1;\n        int r = 2 * i + 2;\n        if (l < n && arr[l] > arr[largest]) {\n            largest = l;\n        }\n        if (r < n && arr[r] > arr[largest]) {\n            largest = r;\n        }\n        if (largest != i) {\n            int temp = arr[i];\n            arr[i] = arr[largest];\n            arr[largest] = temp;\n            heapify(arr, n, largest);\n        }\n    }\n\n    public static int[] heapSort(int[] arr) {\n        int n = arr.length;\n        for (int i = n / 2 - 1; i >= 0; i--) {\n            heapify(arr, n, i);\n        }\n        for (int i = n - 1; i > 0; i--) {\n            int temp = arr[0];\n            arr[0] = arr[i];\n            arr[i] = temp;\n            heapify(arr, i, 0);\n        }\n        return arr;\n    }\n}",
      "c": "#include <stdio.h>\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int l = 2 * i + 1;\n    int r = 2 * i + 2;\n    if (l < n && arr[l] > arr[largest]) {\n        largest = l;\n    }\n    if (r < n && arr[r] > arr[largest]) {\n        largest = r;\n    }\n    if (largest != i) {\n        int temp = arr[i];\n        arr[i] = arr[largest];\n        arr[largest] = temp;\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapSort(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapify(arr, n, i);\n    }\n    for (int i = n - 1; i > 0; i--) {\n        int temp = arr[0];\n        arr[0] = arr[i];\n        arr[i] = temp;\n        heapify(arr, i, 0);\n    }\n}",
      "cpp": "#include <iostream>\nusing namespace std;\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int l = 2 * i + 1;\n    int r = 2 * i + 2;\n    if (l < n && arr[l] > arr[largest]) {\n        largest = l;\n    }\n    if (r < n && arr[r] > arr[largest]) {\n        largest = r;\n    }\n    if (largest != i) {\n        swap(arr[i], arr[largest]);\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapSort(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--) {\n        heapify(arr, n, i);\n    }\n    for (int i = n - 1; i > 0; i--) {\n        swap(arr[0], arr[i]);\n        heapify(arr, i, 0);\n    }\n}",
      "csharp": "using System;\n\nclass HeapSort {\n    static void Heapify(int[] arr, int n, int i) {\n        int largest = i;\n        int l = 2 * i + 1;\n        int r = 2 * i + 2;\n        if (l < n && arr[l] > arr[largest]) {\n            largest = l;\n        }\n        if (r < n && arr[r] > arr[largest]) {\n            largest = r;\n        }\n        if (largest != i) {\n            int temp = arr[i];\n            arr[i] = arr[largest];\n            arr[largest] = temp;\n            Heapify(arr, n, largest);\n        }\n    }\n\n    public static int[] HeapSortMethod(int[] arr) {\n        int n = arr.Length;\n        for (int i = n / 2 - 1; i >= 0; i--) {\n            Heapify(arr, n, i);\n        }\n        for (int i = n - 1; i > 0; i--) {\n            int temp = arr[0];\n            arr[0] = arr[i];\n            arr[i] = temp;\n            Heapify(arr, i, 0);\n        }\n        return arr;\n    }\n}",
      "javascript": "function heapify(arr, n, i) {\n    let largest = i;\n    let l = 2 * i + 1;\n    let r = 2 * i + 2;\n    if (l < n && arr[l] > arr[largest]) {\n        largest = l;\n    }\n    if (r < n && arr[r] > arr[largest]) {\n        largest = r;\n    }\n    if (largest !== i) {\n        [arr[i], arr[largest]] = [arr[largest], arr[i]];\n        heapify(arr, n, largest);\n    }\n}\n\nfunction heapSort(arr) {\n    let n = arr.length;\n    for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n        heapify(arr, n, i);\n    }\n    for (let i = n - 1; i > 0; i--) {\n        [arr[0], arr[i]] = [arr[i], arr[0]];\n        heapify(arr, i, 0);\n    }\n    return arr;\n}"
    },
    {
      "key": "radixSort",
      "python": "def countingSort(arr, exp):\n    n = len(arr)\n    output = [0] * n\n    count = [0] * 10\n    for i in range(n):\n        index = arr[i] // exp\n        count[index % 10] += 1\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n    i = n - 1\n    while i >= 0:\n        index = arr[i] // exp\n        output[count[index % 10] - 1] = arr[i]\n        count[index % 10] -= 1\n        i -= 1\n    for i in range(n):\n        arr[i] = output[i]\n\ndef radixSort(arr):\n    max_num = max(arr)\n    exp = 1\n    while max_num // exp > 0:\n        countingSort(arr, exp)\n        exp *= 10\n    return arr",
      "java": "public class RadixSort {\n    public static void countingSort(int[] arr, int exp) {\n        int n = arr.length;\n        int[] output = new int[n];\n        int[] count = new int[10];\n        for (int i = 0; i < n; i++) {\n            int index = arr[i] / exp;\n            count[index % 10]++;\n        }\n        for (int i = 1; i < 10; i++) {\n            count[i] += count[i - 1];\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            int index = arr[i] / exp;\n            output[count[index % 10] - 1] = arr[i];\n            count[index % 10]--;\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i] = output[i];\n        }\n    }\n\n    public static int[] radixSort(int[] arr) {\n        int max = Arrays.stream(arr).max().getAsInt();\n        for (int exp = 1; max / exp > 0; exp *= 10) {\n            countingSort(arr, exp);\n        }\n        return arr;\n    }\n}",
      "c": "#include <stdio.h>\nvoid countingSort(int arr[], int n, int exp) {\n    int output[n];\n    int count[10] = {0};\n    for (int i = 0; i < n; i++) {\n        int index = arr[i] / exp;\n        count[index % 10]++;\n    }\n    for (int i = 1; i < 10; i++) {\n        count[i] += count[i - 1];\n    }\n    for (int i = n - 1; i >= 0; i--) {\n        int index = arr[i] / exp;\n        output[count[index % 10] - 1] = arr[i];\n        count[index % 10]--;\n    }\n    for (int i = 0; i < n; i++) {\n        arr[i] = output[i];\n    }\n}\n\nvoid radixSort(int arr[], int n) {\n    int max = arr[0];\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    for (int exp = 1; max / exp > 0; exp *= 10) {\n        countingSort(arr, n, exp);\n    }\n}",
      "cpp": "#include <iostream>\nusing namespace std;\nvoid countingSort(int arr[], int n, int exp) {\n    int output[n];\n    int count[10] = {0};\n    for (int i = 0; i < n; i++) {\n        int index = arr[i] / exp;\n        count[index % 10]++;\n    }\n    for (int i = 1; i < 10; i++) {\n        count[i] += count[i - 1];\n    }\n    for (int i = n - 1; i >= 0; i--) {\n        int index = arr[i] / exp;\n        output[count[index % 10] - 1] = arr[i];\n        count[index % 10]--;\n    }\n    for (int i = 0; i < n; i++) {\n        arr[i] = output[i];\n    }\n}\n\nvoid radixSort(int arr[], int n) {\n    int max = arr[0];\n    for (int i = 1; i < n; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    for (int exp = 1; max / exp > 0; exp *= 10) {\n        countingSort(arr, n, exp);\n    }\n}",
      "csharp": "using System;\n\nclass RadixSort {\n    static void CountingSort(int[] arr, int n, int exp) {\n        int[] output = new int[n];\n        int[] count = new int[10];\n        for (int i = 0; i < n; i++) {\n            int index = arr[i] / exp;\n            count[index % 10]++;\n        }\n        for (int i = 1; i < 10; i++) {\n            count[i] += count[i - 1];\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            int index = arr[i] / exp;\n            output[count[index % 10] - 1] = arr[i];\n            count[index % 10]--;\n        }\n        for (int i = 0; i < n; i++) {\n            arr[i] = output[i];\n        }\n    }\n\n    public static int[] RadixSortMethod(int[] arr) {\n        int n = arr.Length;\n        int max = arr.Max();\n        for (int exp = 1; max / exp > 0; exp *= 10) {\n            CountingSort(arr, n, exp);\n        }\n        return arr;\n    }\n}",
      "javascript": "function countingSort(arr, exp) {\n    let n = arr.length;\n    let output = new Array(n);\n    let count = new Array(10).fill(0);\n    for (let i = 0; i < n; i++) {\n        let index = Math.floor(arr[i] / exp);\n        count[index % 10]++;\n    }\n    for (let i = 1; i < 10; i++) {\n        count[i] += count[i - 1];\n    }\n    for (let i = n - 1; i >= 0; i--) {\n        let index = Math.floor(arr[i] / exp);\n        output[count[index % 10] - 1] = arr[i];\n        count[index % 10]--;\n    }\n    for (let i = 0; i < n; i++) {\n        arr[i] = output[i];\n    }\n}\n\nfunction radixSort(arr) {\n    let max = Math.max(...arr);\n    for (let exp = 1; Math.floor(max / exp) > 0; exp *= 10) {\n        countingSort(arr, exp);\n    }\n    return arr;\n}"
    },
    {
      "key": "bucketSort",
      "python": "def bucketSort(arr):\n    if len(arr) == 0:\n        return arr\n    bucket_count = 10\n    min_value, max_value = min(arr), max(arr)\n    bucket_range = (max_value - min_value) / bucket_count\n    buckets = [[] for _ in range(bucket_count)]\n    for num in arr:\n        index = int((num - min_value) / bucket_range)\n        if index == bucket_count:\n            index -= 1\n        buckets[index].append(num)\n    for i in range(bucket_count):\n        buckets[i] = sorted(buckets[i])\n    return [num for bucket in buckets for num in bucket]",
      "java": "public class BucketSort {\n    public static int[] bucketSort(int[] arr) {\n        if (arr.length == 0) return arr;\n        int minValue = arr[0], maxValue = arr[0];\n        for (int num : arr) {\n            if (num < minValue) minValue = num;\n            if (num > maxValue) maxValue = num;\n        }\n        int bucketCount = 10;\n        float bucketRange = (float)(maxValue - minValue) / bucketCount;\n        ArrayList<Integer>[] buckets = new ArrayList[bucketCount];\n        for (int i = 0; i < bucketCount; i++) {\n            buckets[i] = new ArrayList<>();\n        }\n        for (int num : arr) {\n            int index = (int)((num - minValue) / bucketRange);\n            if (index == bucketCount) index--;\n            buckets[index].add(num);\n        }\n        for (ArrayList<Integer> bucket : buckets) {\n            Collections.sort(bucket);\n        }\n        ArrayList<Integer> sortedArr = new ArrayList<>();\n        for (ArrayList<Integer> bucket : buckets) {\n            sortedArr.addAll(bucket);\n        }\n        return sortedArr.stream().mapToInt(i -> i).toArray();\n    }\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\nvoid bucketSort(float arr[], int n) {\n    if (n <= 0) return;\n    float minValue = arr[0], maxValue = arr[0];\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < minValue) minValue = arr[i];\n        if (arr[i] > maxValue) maxValue = arr[i];\n    }\n    int bucketCount = 10;\n    float bucketRange = (maxValue - minValue) / bucketCount;\n    float* buckets[bucketCount];\n    int bucketSizes[bucketCount];\n    for (int i = 0; i < bucketCount; i++) {\n        buckets[i] = (float*)malloc(sizeof(float) * n);\n        bucketSizes[i] = 0;\n    }\n    for (int i = 0; i < n; i++) {\n        int index = (arr[i] - minValue) / bucketRange;\n        if (index == bucketCount) index--;\n        buckets[index][bucketSizes[index]++] = arr[i];\n    }\n    for (int i = 0; i < bucketCount; i++) {\n        qsort(buckets[i], bucketSizes[i], sizeof(float), compare);\n    }\n    int index = 0;\n    for (int i = 0; i < bucketCount; i++) {\n        for (int j = 0; j < bucketSizes[i]; j++) {\n            arr[index++] = buckets[i][j];\n        }\n    }\n}\nint compare(const void* a, const void* b) {\n    return (*(float*)a - *(float*)b);\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nvoid bucketSort(vector<float>& arr) {\n    if (arr.empty()) return;\n    float minValue = arr[0], maxValue = arr[0];\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] < minValue) minValue = arr[i];\n        if (arr[i] > maxValue) maxValue = arr[i];\n    }\n    int bucketCount = 10;\n    float bucketRange = (maxValue - minValue) / bucketCount;\n    vector<vector<float>> buckets(bucketCount);\n    for (int i = 0; i < arr.size(); i++) {\n        int index = (arr[i] - minValue) / bucketRange;\n        if (index == bucketCount) index--;\n        buckets[index].push_back(arr[i]);\n    }\n    for (int i = 0; i < bucketCount; i++) {\n        sort(buckets[i].begin(), buckets[i].end());\n    }\n    arr.clear();\n    for (int i = 0; i < bucketCount; i++) {\n        arr.insert(arr.end(), buckets[i].begin(), buckets[i].end());\n    }\n}",
      "csharp": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass BucketSort {\n    public static void BucketSortMethod(ref List<float> arr) {\n        if (arr.Count == 0) return;\n        float minValue = arr.Min(), maxValue = arr.Max();\n        int bucketCount = 10;\n        float bucketRange = (maxValue - minValue) / bucketCount;\n        List<List<float>> buckets = new List<List<float>>();\n        for (int i = 0; i < bucketCount; i++) {\n            buckets.Add(new List<float>());\n        }\n        foreach (var num in arr) {\n            int index = (int)((num - minValue) / bucketRange);\n            if (index == bucketCount) index--;\n            buckets[index].Add(num);\n        }\n        foreach (var bucket in buckets) {\n            bucket.Sort();\n        }\n        arr.Clear();\n        foreach (var bucket in buckets) {\n            arr.AddRange(bucket);\n        }\n    }\n}",
      "javascript": "function bucketSort(arr) {\n    if (arr.length === 0) return arr;\n    let minValue = Math.min(...arr);\n    let maxValue = Math.max(...arr);\n    let bucketCount = 10;\n    let bucketRange = (maxValue - minValue) / bucketCount;\n    let buckets = Array.from({ length: bucketCount }, () => []);\n    for (let i = 0; i < arr.length; i++) {\n        let index = Math.floor((arr[i] - minValue) / bucketRange);\n        if (index === bucketCount) index--;\n        buckets[index].push(arr[i]);\n    }\n    for (let i = 0; i < bucketCount; i++) {\n        buckets[i].sort((a, b) => a - b);\n    }\n    return [].concat(...buckets);\n}"
    },
    {
      "key": "introspectiveSort",
      "python": "import sys\nimport heapq\n\ndef introsort(arr):\n    max_depth = 2 * (len(arr).bit_length() - 1)\n    _introsort(arr, 0, len(arr) - 1, max_depth)\n    return arr\n\ndef _introsort(arr, left, right, depth_limit):\n    size = right - left + 1\n    if size < 16:\n        insertion_sort(arr, left, right)\n    elif depth_limit == 0:\n        heap_sort(arr, left, right)\n    else:\n        pivot = partition(arr, left, right)\n        _introsort(arr, left, pivot - 1, depth_limit - 1)\n        _introsort(arr, pivot + 1, right, depth_limit - 1)\n\ndef insertion_sort(arr, left, right):\n    for i in range(left + 1, right + 1):\n        key = arr[i]\n        j = i - 1\n        while j >= left and arr[j] > key:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n\ndef heap_sort(arr, left, right):\n    heapq.heapify(arr[left:right + 1])\n    sorted_part = [heapq.heappop(arr[left:right + 1]) for _ in range(right - left + 1)]\n    arr[left:right + 1] = sorted_part\n\ndef partition(arr, left, right):\n    pivot = arr[right]\n    i = left - 1\n    for j in range(left, right):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[right] = arr[right], arr[i + 1]\n    return i + 1",
      "java": "import java.util.Arrays;\npublic class IntroSort {\n    private static final int INSERTION_SORT_THRESHOLD = 16;\n    public static void introsort(int[] arr) {\n        int maxDepth = 2 * (int) (Math.log(arr.length) / Math.log(2));\n        introsortUtil(arr, 0, arr.length - 1, maxDepth);\n    }\n    private static void introsortUtil(int[] arr, int left, int right, int depthLimit) {\n        if (right - left < INSERTION_SORT_THRESHOLD) {\n            insertionSort(arr, left, right);\n        } else if (depthLimit == 0) {\n            heapSort(arr, left, right);\n        } else {\n            int pivot = partition(arr, left, right);\n            introsortUtil(arr, left, pivot - 1, depthLimit - 1);\n            introsortUtil(arr, pivot + 1, right, depthLimit - 1);\n        }\n    }\n    private static void insertionSort(int[] arr, int left, int right) {\n        for (int i = left + 1; i <= right; i++) {\n            int key = arr[i];\n            int j = i - 1;\n            while (j >= left && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j--;\n            }\n            arr[j + 1] = key;\n        }\n    }\n    private static void heapSort(int[] arr, int left, int right) {\n        Arrays.sort(arr, left, right + 1);\n    }\n    private static int partition(int[] arr, int left, int right) {\n        int pivot = arr[right];\n        int i = left - 1;\n        for (int j = left; j < right; j++) {\n            if (arr[j] <= pivot) {\n                i++;\n                int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;\n            }\n        }\n        int temp = arr[i + 1]; arr[i + 1] = arr[right]; arr[right] = temp;\n        return i + 1;\n    }\n}",
      "c": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\nvoid introsort(int arr[], int n);\nvoid quicksort(int arr[], int left, int right, int depthLimit);\nvoid heapSort(int arr[], int n);\nvoid insertionSort(int arr[], int left, int right);\nint partition(int arr[], int left, int right);\nvoid introsort(int arr[], int n) {\n    int depthLimit = 2 * log(n) / log(2);\n    quicksort(arr, 0, n - 1, depthLimit);\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nvoid insertionSort(vector<int>& arr, int left, int right) {\n    for (int i = left + 1; i <= right; i++) {\n        int key = arr[i], j = i - 1;\n        while (j >= left && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}",
      "csharp": "using System;\nusing System.Collections.Generic;\nclass IntroSort {\n    static int Partition(int[] arr, int left, int right) {\n        int pivot = arr[right];\n        int i = left - 1;\n        for (int j = left; j < right; j++) {\n            if (arr[j] <= pivot) {\n                i++;\n                (arr[i], arr[j]) = (arr[j], arr[i]);\n            }\n        }\n        (arr[i + 1], arr[right]) = (arr[right], arr[i + 1]);\n        return i + 1;\n    }\n}",
      "javascript": "function introsort(arr) {\n    const maxDepth = 2 * Math.floor(Math.log2(arr.length));\n    introsortHelper(arr, 0, arr.length - 1, maxDepth);\n    return arr;\n}\nfunction introsortHelper(arr, left, right, depthLimit) {\n    if (right - left < 16) {\n        insertionSort(arr, left, right);\n    } else if (depthLimit === 0) {\n        arr.sort((a, b) => a - b);\n    } else {\n        const pivot = partition(arr, left, right);\n        introsortHelper(arr, left, pivot - 1, depthLimit - 1);\n        introsortHelper(arr, pivot + 1, right, depthLimit - 1);\n    }\n}" 
    }
    
    
    
    
    
  ]
  