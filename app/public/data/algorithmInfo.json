[

    {
    "key": "bubbleSort",
    "algorithm": "Bubble Sort",
    "description": "Bubble Sort is a simple comparison-based sorting algorithm where adjacent elements are compared and swapped if they are in the wrong order. This process repeats until the entire array is sorted.",
    "steps": [
      "Iterate through the array multiple times.",
      "During each pass, compare adjacent elements:",
      "If the current element is greater than the next, swap them.",
      "After each pass, the largest unsorted element 'bubbles up' to its correct position at the end of the array.",
      "Repeat until no swaps are needed, indicating the array is sorted."
    ],
    "keyConcepts": [
      "Adjacent Comparison",
      "Swapping",
      "Passes",
      "Optimization: Stop the process early if no swaps occur in a pass (array is already sorted)."
    ],
    "complexity": {
      "time": {
        "worstCase": "O(n^2)",
        "bestCase": "O(n) with early exit optimization",
        "averageCase": "O(n^2)"
      },
      "space": "O(1)"
    },
    "advantages": [
      "Simple and easy to implement.",
      "Best case O(n) if optimized for early exit."
    ],
    "disadvantages": [
      "Inefficient for large datasets due to O(n^2) complexity.",
      "Not suitable for real-world applications requiring high performance."
    ],
    "practicalUse": [
      "Educational purposes to demonstrate sorting concepts.",
      "Small datasets where implementation simplicity is more critical than efficiency."
    ]
    },
    {
        "key": "mergeSortTopDown",
        "algorithm": "Merge Sort (Top-Down)",
        "description": "Merge Sort is a divide-and-conquer sorting algorithm that divides the array into halves, recursively sorts them, and then merges the sorted halves into a single sorted array.",
        "steps": [
          "Divide the array into two halves.",
          "Recursively apply Merge Sort to each half.",
          "Once the halves are sorted, merge them into a single sorted array:",
          "Compare elements from each half and add the smaller element to the result array.",
          "Repeat until all elements from both halves are merged."
        ],
        "keyConcepts": [
          "Divide and Conquer",
          "Recursion",
          "Merging",
          "Stable Sorting (maintains the relative order of equal elements)."
        ],
        "complexity": {
          "time": {
            "worstCase": "O(n log n)",
            "bestCase": "O(n log n)",
            "averageCase": "O(n log n)"
          },
          "space": "O(n) for temporary arrays"
        },
        "advantages": [
          "Consistent O(n log n) performance for all cases.",
          "Stable sorting algorithm.",
          "Well-suited for sorting linked lists."
        ],
        "disadvantages": [
          "Requires additional space for merging (O(n) space complexity).",
          "Recursion can cause a stack overflow for very large arrays."
        ],
        "practicalUse": [
          "Sorting datasets that require stability.",
          "Sorting linked lists due to its efficient merging process.",
          "Useful in external sorting where data is stored on disk."
        ]
      },
      {
        "key": "mergeSortBottomUp",
        "algorithm": "Merge Sort (Bottom-Up)",
        "description": "Bottom-Up Merge Sort is an iterative version of the Merge Sort algorithm. It starts with small subarrays and iteratively merges them into larger sorted arrays until the entire array is sorted.",
        "steps": [
          "Divide the array into subarrays of size 1.",
          "Iteratively merge adjacent subarrays into larger sorted arrays.",
          "Double the size of subarrays in each iteration until the entire array is sorted."
        ],
        "keyConcepts": [
          "Iterative Process",
          "Merging",
          "Stable Sorting (maintains the relative order of equal elements)."
        ],
        "complexity": {
          "time": {
            "worstCase": "O(n log n)",
            "bestCase": "O(n log n)",
            "averageCase": "O(n log n)"
          },
          "space": "O(n) for temporary arrays"
        },
        "advantages": [
          "Consistent O(n log n) performance for all cases.",
          "Avoids recursion, making it suitable for systems with limited stack space.",
          "Stable sorting algorithm."
        ],
        "disadvantages": [
          "Requires additional space for merging (O(n) space complexity).",
          "May be less intuitive compared to the recursive top-down approach."
        ],
        "practicalUse": [
          "Sorting datasets that require stability.",
          "Systems where recursion is not ideal or stack space is limited.",
          "Useful in external sorting when dealing with large datasets stored on disk."
        ]
      },
      {
        "key": "quickSort",
        "algorithm": "Quick Sort",
        "description": "Quick Sort is a divide-and-conquer sorting algorithm that works by selecting a pivot element, partitioning the array into elements less than the pivot and greater than the pivot, and recursively sorting the subarrays.",
        "steps": [
          "Choose a pivot element from the array.",
          "Partition the array into two subarrays: one with elements smaller than the pivot and one with elements greater than the pivot.",
          "Recursively apply Quick Sort to the subarrays.",
          "The base case is when the subarray has fewer than two elements."
        ],
        "keyConcepts": [
          "Divide and Conquer",
          "Pivot Selection",
          "Partitioning",
          "Recursion"
        ],
        "complexity": {
          "time": {
            "worstCase": "O(n^2) with poor pivot selection",
            "bestCase": "O(n log n) with good pivot selection",
            "averageCase": "O(n log n)"
          },
          "space": "O(log n) for recursion stack"
        },
        "advantages": [
          "Efficient for large datasets with average-case O(n log n) time complexity.",
          "In-place sorting, requires minimal additional memory.",
          "Faster than merge sort for smaller arrays."
        ],
        "disadvantages": [
          "Worst-case O(n^2) time complexity when pivot selection is poor.",
          "Not stable (does not maintain the relative order of equal elements).",
          "Recursion stack can cause stack overflow for large arrays."
        ],
        "practicalUse": [
          "Sorting large datasets in applications where space efficiency is important.",
          "Used in various built-in sorting functions in many programming languages.",
          "Efficient for sorting arrays in-memory."
        ]
      },
      {
        "key": "selectionSort",
        "algorithm": "Selection Sort",
        "description": "Selection Sort is a simple comparison-based sorting algorithm. It works by repeatedly finding the smallest (or largest) element from the unsorted part of the array and swapping it with the first unsorted element.",
        "steps": [
          "Start with the first element in the array.",
          "Find the smallest element in the unsorted portion of the array.",
          "Swap the smallest element with the first unsorted element.",
          "Move to the next element and repeat the process for the remaining unsorted portion of the array.",
          "Continue until the entire array is sorted."
        ],
        "keyConcepts": [
          "Selection of the smallest (or largest) element",
          "Swapping",
          "In-place Sorting"
        ],
        "complexity": {
          "time": {
            "worstCase": "O(n^2)",
            "bestCase": "O(n^2)",
            "averageCase": "O(n^2)"
          },
          "space": "O(1)"
        },
        "advantages": [
          "Simple to implement.",
          "In-place sorting (no extra memory required).",
          "Does not require recursion."
        ],
        "disadvantages": [
          "Inefficient for large datasets due to O(n^2) time complexity.",
          "Does not take advantage of partially sorted arrays.",
          "Not a stable sorting algorithm."
        ],
        "practicalUse": [
          "Educational purposes to demonstrate sorting concepts.",
          "Small datasets where simplicity is more important than efficiency."
        ]
      },
      {
        "key": "insertionSort",
        "algorithm": "Insertion Sort",
        "description": "Insertion Sort is a simple comparison-based sorting algorithm. It builds the final sorted array one item at a time by repeatedly picking the next element and inserting it into its correct position in the already sorted portion of the array.",
        "steps": [
          "Start with the second element in the array (the first element is already considered sorted).",
          "Compare the current element with the elements in the sorted portion of the array.",
          "Move all elements that are greater than the current element one position to the right.",
          "Insert the current element into its correct position in the sorted portion.",
          "Repeat for all remaining elements in the array."
        ],
        "keyConcepts": [
          "Building Sorted Array",
          "Insertion",
          "Shifting Elements"
        ],
        "complexity": {
          "time": {
            "worstCase": "O(n^2) when the array is in reverse order",
            "bestCase": "O(n) when the array is already sorted",
            "averageCase": "O(n^2)"
          },
          "space": "O(1)"
        },
        "advantages": [
          "Simple to implement.",
          "Efficient for small datasets or nearly sorted arrays.",
          "In-place sorting (no extra memory required).",
          "Stable sorting algorithm (maintains the relative order of equal elements)."
        ],
        "disadvantages": [
          "Inefficient for large datasets with O(nÂ²) time complexity.",
          "Does not take advantage of fully sorted or partially sorted arrays in the worst case."
        ],
        "practicalUse": [
          "Sorting small or nearly sorted datasets.",
          "Used in practical applications like sorting small lists in algorithms that use a hybrid approach."
        ]
      }
      
      
      
      
]
  